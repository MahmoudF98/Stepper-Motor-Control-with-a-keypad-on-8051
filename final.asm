ORG 00H		// Starting address
SJMP MAIN		// Jumps to the MAIN function

ORG 003H		// Starting address for the ISR(INT0)
ACALL ISR		// Calls the ISR (interrupt service routine)
RETI		// Retutn from the interrput
 
MAIN:
// Setting the external interrupt0
SETB TCON.0		// Interrupt generated by a falling edge signal at INT0 (pin12)
SETB IE.0		// Enables the external interrupt
SETB IE.7		// Enables the global interrupt control

MOV R7,#00H		// Flag to control the movement of the motor (control flag)

MOV P0,#07H		// Initializing push button switches as input device at P0.0, P0.1, P0.2 (0000 0111b)

READP0:
	MOV A,P0		// Moving the port value to Accumulator.
	RRC A		// Checking the vale of Port 0 to know if switch1(P0.0) is pressed or not
	JC NXT1		// If switch1 is not pressed then jump to NXT1 to check if switch2 is pressed
	
SWITCH1:		// If switch1 is pressed (Half step sequence)
	CJNE R7,#00H,AGAIN		// Checking the value of the control flag
	// While the control flag is zero:
	ACALL DELAY
	MOV R1,#02H
	MOV P2,R1
	ACALL DELAY
	
	MOV R1,#03H		
	MOV P2,R1
	ACALL DELAY
	
	MOV R1,#01H
	MOV P2,R1
	ACALL DELAY
	
	MOV R1,#09H
	MOV P2,R1
	ACALL DELAY
	
	MOV R1,#08H
	MOV P2,R1
	ACALL DELAY
	
	MOV R1,#0CH
	MOV P2,R1
	ACALL DELAY
	
	MOV R1,#04H
	MOV P2,R1
	ACALL DELAY
	
	MOV R1,#06H
	MOV P2,R1
	
	SJMP SWITCH1
	
AGAIN:		// Make the control flag zero again after the interrupt happens and reread P0 again
	MOV R7,#00H	
    SJMP READP0		// Re read port value again.

NXT1:		// If switch1 is not pressed:
	RRC A		// Checking the value of Port 0 to know if switch 2 is pressed or not
	JC NXT2		// Jumping to NXT2 to check status of switch 3 (as switch 2 is not pressed)
	
SWITCH2:		// If switch 2 is pressed (Full step sequence)
	CJNE R7,#00H,AGAIN		// Check the control flag value
	// While the control flag is zero:
	ACALL DELAY
	
	MOV R1,#03H
	MOV P2,R1
	ACALL DELAY

	MOV R1,#09H
	MOV P2,R1
	ACALL DELAY

	MOV R1,#0CH
	MOV P2,R1
	ACALL DELAY

	MOV R1,#06H
	MOV P2,R1	
	SJMP SWITCH2

NXT2:		// If switch1 is not pressed:
	RRC A		// Checking the value of Port 0 to know if switch 3 is pressed or not
	JC READP0 		// Jumping to READP0 to check status of switch 1 again (as switch 3 is not pressed)
	
SWITCH3:		// Rotate the stepper motor with a given angle from the keypad
	MOV R1,#0D		// Initializing the least significant byte of the angle with zero
	MOV R2,#0D		// Initializing the most significant byte of the angle with zero
	ACALL GETKEY	// Getting the key from keypad
	
CHECK:
	CJNE A,#10D,FORMNUM		// If the key value is (10 --> '*') rotate to the given angle, if not form the angle value

ANGLE0:	
	CJNE R1,#0D,ANGLE45			// if (R1 == 0 && R2 == 0) rotate to angle 0, else jumb to ANGLE45
	CJNE R2,#0H,ANGLE45
	MOV P2,#06H
	SJMP READP0
ANGLE45:
    CJNE R1,#45D,ANGLE90		// if (R1 == 45 && R2 == 0) rotate to angle 45, else jumb to ANGLE90
	CJNE R2,#0H,ANGLE90
	MOV P2,#02H
	SJMP READP0	
ANGLE90:
    CJNE R1,#90D,ANGLE135		// if (R1 == 90 && R2 == 0) rotate to angle 90, else jumb to ANGLE135
	CJNE R2,#0H,ANGLE135
	MOV P2,#03H
	AJMP READP0
ANGLE135:
    CJNE R1,#135D,ANGLE180		// if (R1 == 135 && R2 == 0) rotate to angle 135, else jumb to ANGLE180
	CJNE R2,#0H,ANGLE180
	MOV P2,#01H
	AJMP READP0
ANGLE180:
    CJNE R1,#180D,ANGLE225		// if (R1 == 180 && R2 == 0) rotate to angle 180, else jumb to ANGLE225
	CJNE R2,#0H,ANGLE225
	MOV P2,#09H
	AJMP READP0
ANGLE225:
    CJNE R1,#225D,ANGLE270		// if (R1 == 225 && R2 == 0) rotate to angle 225, else jumb to ANGLE270
	CJNE R2,#0H,ANGLE270
	MOV P2,#08H
	AJMP READP0		
ANGLE270:
    CJNE R1,#0EH,ANGLE315		// if (R1 == 0EH && R2 == 01H) rotate to angle 270, else jumb to ANGLE315
	CJNE R2,#01H,ANGLE315
	MOV P2,#0CH
	AJMP READP0
ANGLE315:
    CJNE R1,#3BH,ABOVE		// if (R1 == 3BH && R2 == 01H) rotate to angle 315, else jumb to ABOVE
	CJNE R2,#1H,ABOVE
	MOV P2,#04H
	AJMP READP0
ABOVE:		// If angle is >= 360 degree, subtract 360 and repeat again
    MOV A,R1
	CLR PSW.7		// Clear Carry flag (no SUB)
	SUBB A,#68H		// As (360D --> 0168H), subtract 68H from the least significant byte of the angle value (R1 - 68H)
	MOV R1,A		// Store the result in R1
	MOV A,R2		
	SUBB A,#01H		// subtract with borrow 01H from the most significant byte of the angle value (R2 - 01H)
	MOV R2,A		// Store the result in R2
	SJMP ANGLE0		// Check Angle value again

// To Form the angle value (digits) 
// ((R2->R1) * 10) + NEW KEY
FORMNUM:
	MOV R0,A
	MOV A,R1
	MOV B,#10D
	MUL AB
	MOV R1,A
	MOV R3,B
	MOV A,R2
	MOV B,#10D
	MUL AB
	ADD A,R3
	MOV R2,A
    MOV A,R1
	ADD A,R0
	MOV R1,A
	MOV A,R2
	ADDC A,#0D
	MOV R2,A

	ACALL GETKEY		// Get another key
	AJMP CHECK		// Check if the key is '*'

DELAY:		// DELAY(Timer) function of 0.5 sec
	MOV R4,#10D		// Counter of 10 as 10 * 50ms = 0.5 sec
	BACK:
		MOV TMOD ,#01H		// Timer0 in mode 1 (over flow)
		MOV TH0 ,#03CH		// Initial value of timer0 (15536 decimal to count 50ms)
		MOV TL0 ,#0B0H		// 15536D = 3CB0
		SETB TCON.4		// Set TR0 in reg TCON(Timer Control Register) to start the timer
		L1:JNB TCON.5,L1 // Wait untill the timer over flow flag is set (Jump if bit is not set)
		CLR TCON.4		// Clear TR0 in reg TCON to stop the timer
		CLR TCON.5		// Clear the timer over flow flag
		DJNZ R4 ,BACK // Decrement R4 and jump if not zero
	RET // Return from DELAY
	
// Function to get the key from 3*4 keypad
GETKEY:
/* each time only one of the column pins will be output
   and the rest will be input pins include the row pins */
MOV P1,#11111111B // loads P1 with all 1's

COLMN0:
        SETB P1.6		// Make the last column as input pin
        CLR P1.4		// Make column 1 as output
		MOV R0,#0D		// Store column number
		MOV R5,#1D		// Load R5 with the next column number
	    SJMP ROWS 		// Scan the rows to get the key

COLMN1:
		SETB P1.4
        CLR P1.5 
		MOV R0,#1D
		MOV R5,#2D
	    SJMP ROWS 
		
COLMN2:
		SETB P1.5
        CLR P1.6
		MOV R0,#2D
		MOV R5,#0D
	    SJMP ROWS 		
		
ROWS:
	 ROW0:
		 JB P1.0,ROW1		// Checks whether ROW 0 is LOW (If key is pressed) and if not(P1.0 is 1) jump to ROW 1
		 MOV R2,#0D			// Store ROW number
		 SJMP FOUND			// Jump to found to get the key value

	 ROW1:
		 JB P1.1,ROW2
		 MOV R2,#1D
		 SJMP FOUND

	 ROW2:
		 JB P1.2,ROW3
		 MOV R2,#2D
		 SJMP FOUND

	 ROW3:
		 JB P1.3,NEXT		// If ROW 3 is HIGH (If key is not pressed) Jumb to NEXT to get the next column
		 MOV R2,#3D
		 SJMP FOUND
	 
NEXT:		// Continuing to the next column (last column number is stored in R5)
	 C0:
		 CJNE R5,#0D,C1		// Jumb to Column 0 if the last column was column 2
		 SJMP COLMN0
     C1:
		 CJNE R5,#1D,C2
		 SJMP COLMN1
	 C2:
		 SJMP COLMN2

FOUND:		// Getting the key value
	ACALL adjustKeyNumber 
	RET
	  
adjustKeyNumber:		// key value = ((row*N_col) + col + 1) = ((R2*3) + R0 +1)
	 MOV A,R2
	 MOV B,#3D
	 MUL AB
	 MOV R2,A
	 MOV A,R0
	 ADD A,#1D
	 ADD A,R2
     ZERO:
		CJNE A,#11D,RETURN		// If the key value is 11 return zero
		MOV A,#0D
	 RETURN:
		ACALL DELAY		// Wait 0.5s before getting the next key
	 RET
	 
ISR:		// Interrupt service routine
	MOV R7,#01H		// Stopping the stepper motor
	RET		// Jumps to RETI

END // End of the fucking program